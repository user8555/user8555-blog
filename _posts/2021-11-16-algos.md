---
layout: post
title: Coding challenges
---

## Find interval containing point

```rust
/// Given a bunch of non-overlapping intervals, find if the point is covered by a range
/// - sort by start, within that sort by end
/// - ranges are non-overlapping
/// - binary search key on start values
/// - will return an index that contains that given key or an insertion point
/// - insertion point and non-overlapping ranges implies that the
///   start_insertion_point - 1 < key < start_insertion_point
/// - check if key in [start_insertion_point - 1, corresponding_end_range].
///   if yes, key exists in range. Else it does not
use std::vec::Vec;

fn find_overlapping_range(
    mut intervals: Vec<(i64, i64)>, pt: i64,
) -> Option<(i64, i64)> {
    intervals.sort();

    match intervals.binary_search_by(move |probe| probe.0.cmp(&pt)) {
        Ok(i) => Some(intervals[i].clone()),
        Err(i) => {
            if i == 0 || i >= intervals.len() {
                return None;
            } else {
                if intervals[i - 1].0 <= pt && intervals[i - 1].1 > pt {
                    return Some(intervals[i - 1].clone());
                } else {
                    return None;
                }
            }
        }
    }
}

pub fn main() {
    assert_eq!(find_overlapping_range(vec![], 1), None);
    assert_eq!(find_overlapping_range(vec![(1, 3), (4, 10)], 2), Some((1, 3)));
}

```