---
layout: post
title: Coding challenges
---

## Find interval containing point

```rust
/// Given a bunch of non-overlapping intervals, find if the point is covered by a range
/// - sort by start, within that sort by end
/// - ranges are non-overlapping
/// - binary search key on start values
/// - will return an index that contains that given key or an insertion point
/// - insertion point and non-overlapping ranges implies that the
///   start_insertion_point - 1 < key < start_insertion_point
/// - check if key in [start_insertion_point - 1, corresponding_end_range].
///   if yes, key exists in range. Else it does not
use std::vec::Vec;

fn find_overlapping_range(
    mut intervals: Vec<(i64, i64)>, pt: i64,
) -> Option<(i64, i64)> {
    intervals.sort();

    match intervals.binary_search_by(move |probe| probe.0.cmp(&pt)) {
        Ok(i) => Some(intervals[i].clone()),
        Err(i) => {
            if i == 0 || i >= intervals.len() {
                return None;
            } else {
                if intervals[i - 1].0 <= pt && intervals[i - 1].1 > pt {
                    return Some(intervals[i - 1].clone());
                } else {
                    return None;
                }
            }
        }
    }
}

pub fn main() {
    assert_eq!(find_overlapping_range(vec![], 1), None);
    assert_eq!(find_overlapping_range(vec![(1, 3), (4, 10)], 2), Some((1, 3)));
}

```

## Priority queue with decrease key

```rust
struct Pq {
    inner: Vec<i64>,
    m: HashMap<i64, usize>,
}

impl Pq {
    fn push(&mut self, v: i64) {
        self.inner.push(v);
        self.sift_up(self.inner.len() - 1);
    }

    fn pop(&mut self) {
        let min = self.inner[0];
        self.inner.swap(0, self.inner.len() - 1);
        self.inner.truncate(self.inner.len() - 1);
        self.sift_down(0);
        min
    }

    fn decrease_key(&mut self, v: i64, by: i64) {
        let i = 0;
        self.sift_up(i);
    }

    fn sift_up(&mut self, i: usize) {
        while i >= 1 {
            let parent = (i-1)/2;

            if self.inner[parent] < self.inner[i] {
                break;
            } else {
                self.inner.swap(parent, i);
                i = parent;
            }
        }
    }

    fn sift_down(&mut self, i: usize) {
        while i < self.inner.len() {
            let left = 2*i + 1;
            let right = 2*i + 2;

            if self.inner[i] > self.inner[left] {
                self.inner.swap(i, left);                
                i = left;
            } else if self.inner[i] > self.inner[right] {
                self.inner.swap(i, right);                
                i  = right;
            } else {
                break;
            }
        }
    }
}
```