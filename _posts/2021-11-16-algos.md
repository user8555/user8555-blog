---
layout: post
title: Coding challenges
---

## Find interval containing point

```rust
/// Given a bunch of non-overlapping intervals, find if the point is covered by a range
/// - sort by start, within that sort by end
/// - ranges are non-overlapping
/// - binary search key on start values
/// - will return an index that contains that given key or an insertion point
/// - insertion point and non-overlapping ranges implies that the
///   start_insertion_point - 1 < key < start_insertion_point
/// - check if key in [start_insertion_point - 1, corresponding_end_range].
///   if yes, key exists in range. Else it does not
use std::vec::Vec;

fn find_overlapping_range(
    mut intervals: Vec<(i64, i64)>, pt: i64,
) -> Option<(i64, i64)> {
    intervals.sort();

    match intervals.binary_search_by(move |probe| probe.0.cmp(&pt)) {
        Ok(i) => Some(intervals[i].clone()),
        Err(i) => {
            if i == 0 || i >= intervals.len() {
                return None;
            } else {
                if intervals[i - 1].0 <= pt && intervals[i - 1].1 > pt {
                    return Some(intervals[i - 1].clone());
                } else {
                    return None;
                }
            }
        }
    }
}

pub fn main() {
    assert_eq!(find_overlapping_range(vec![], 1), None);
    assert_eq!(find_overlapping_range(vec![(1, 3), (4, 10)], 2), Some((1, 3)));
}

```

## Priority queue with decrease key

```rust
struct Pq {
    inner: Vec<i64>,
    m: HashMap<i64, usize>,
}

impl Pq {
    fn push(&mut self, v: i64) {
        self.inner.push(v);
        self.sift_up(self.inner.len() - 1);
    }

    fn pop(&mut self) {
        let min = self.inner[0];
        self.inner.swap(0, self.inner.len() - 1);
        self.inner.truncate(self.inner.len() - 1);
        self.sift_down(0);
        min
    }

    fn decrease_key(&mut self, v: i64, by: i64) {
        let i = 0;
        self.sift_up(i);
    }

    fn sift_up(&mut self, i: usize) {
        while i >= 1 {
            let parent = (i-1)/2;

            if self.inner[parent] < self.inner[i] {
                break;
            } else {
                self.inner.swap(parent, i);
                i = parent;
            }
        }
    }

    fn sift_down(&mut self, i: usize) {
        while i < self.inner.len() {
            let left = 2*i + 1;
            let right = 2*i + 2;

            if self.inner[i] > self.inner[left] {
                self.inner.swap(i, left);                
                i = left;
            } else if self.inner[i] > self.inner[right] {
                self.inner.swap(i, right);                
                i  = right;
            } else {
                break;
            }
        }
    }
}
```

## Timer based scheduler

```python
import threading
import os
import time
import random
import collections
import sortedcontainers
import concurrent.futures

from concurrent.futures import ThreadPoolExecutor
from threading import Lock, Thread
from sortedcontainers import SortedKeyList, SortedDict

class Task:
    def __init__(self, id):
        self.id = id
    
    def run(self):
        print("ran task {}".format(self.id))

    def __str__(self):
        print("Task {}".format(self.id))

class TimerBasedScheduler:
    def __init__(self, max_workers):
        self.pending_tasks = (Lock(), SortedDict())
        self.pending_tasks[1][0] = []
        self.threadpool = ThreadPoolExecutor(max_workers)

    def schedule(self, task, delay):
        try:
            current_secs = int(time.time())
            new_secs = current_secs + delay
            
            self.pending_tasks[0].acquire()
            if new_secs in self.pending_tasks[1]:
                self.pending_tasks[1][new_secs].add(task)
            else:
                self.pending_tasks[1][new_secs] = [task]

            print("inserted {} {}".format(new_secs, task.id))
            self.pending_tasks[0].release()
        except:
            self.pending_tasks[0].release()    
            raise
        
def run_task(task):
    try:
        print("running task {}".format(task.id))
        task.run()    
    except:
        raise
    
def main_scheduler(tbs_state):
    for cntr in range(0, 20):
        try:                    
            time.sleep(1)            
            curr_secs = int(time.time())                        
            
            # Moving the lock acquisition above time.sleep changes concurrency behavior significantly
            # Go figure.
            tbs_state.pending_tasks[0].acquire()
            
            # copy out all the keys to avoid concurrent modification exception
            expired_times = list(tbs_state.pending_tasks[1].irange(0, curr_secs))
            
            for expired_time in expired_times:                
                if expired_time == 0:
                    continue
                    
                # iterators are not stable. popping affects it. So, copied all the keys
                # via list() after irange()
                tasks = tbs_state.pending_tasks[1].pop(expired_time)
                for task in tasks:             
                    # threadpool.submit() does not accept a kwargs but Thread() does
                    # very weird
                    tbs_state.threadpool.submit(
                        run_task,
                        task = task,
                    )
                    print("submitted for execution {} {}".format(expired_time, task.id))
                
            # There is no RAII. Locks need to be released
            # except block is not run on happy path. So need
            # to release lock here as well
            tbs_state.pending_tasks[0].release()
        except:
            tbs_state.pending_tasks[0].release()
            
            # Re-raise the exception from threads so that we can see the error message
            # while testing it
            raise

if __name__ == '__main__':
    tbs = TimerBasedScheduler(max_workers = 5)
    
    main_timer_thread = Thread(target=main_scheduler, kwargs = {'tbs_state': tbs})
    main_timer_thread.start()
    
    for i in range(0, 10):
        tbs.schedule(Task(i), i)
    
    print('scheduled all')
    main_timer_thread.join()
```
